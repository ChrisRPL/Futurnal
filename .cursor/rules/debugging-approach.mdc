---
description: Systematic debugging approach to avoid getting stuck in fix loops
globs: ["**/*.ts", "**/*.tsx", "**/*.rs", "**/*.py"]
alwaysApply: true
---

# Debugging Protocol: Avoid Fix Loops

## The 3-Strike Rule

If a bug persists after **3 attempted fixes**, STOP making incremental changes. Instead:

1. **Pause** - Do not attempt another quick fix
2. **Research** - Use web search to understand how the library/system actually works internally
3. **Plan** - Write a comprehensive diagnosis before implementing any more fixes

## Signs You're in a Fix Loop

- Same symptom persists after multiple attempts
- Fixes address symptoms, not root causes
- You're guessing rather than understanding
- Error messages are silent or misleading (things just "don't work")

## Required Investigation Steps

When stuck, follow this sequence:

### 1. Understand Internal Behavior
```
Web search: "[library name] [symptom] not working"
Web search: "[library name] internal architecture"
Web search: "[library name] common pitfalls"
```

### 2. Read Source Code / GitHub Issues
- Check library's GitHub issues for similar problems
- Read the actual implementation if needed
- Look for undocumented requirements

### 3. Identify ALL Contributing Factors
Bugs often have multiple causes compounding. Example from react-force-graph-2d:
- Issue 1: nodePointerAreaPaint size mismatch broke clicks
- Issue 2: Inline props caused re-initialization
- Issue 3: No fallback timer for zoomToFit

Each issue alone might not explain the full problem. Fix all root causes together.

### 4. Document Before Implementing
Write a plan that includes:
- Root cause analysis (not just symptoms)
- How the system actually works internally
- All files that need changes
- Testing checklist

## Key Principle

> **Fix root causes, not symptoms.**
>
> A 5px difference in a hit detection canvas can silently break all click events.
> An inline function prop can cause constant re-initialization with zero errors.
> Understanding WHY something fails matters more than WHAT you change.

## Example: Silent Failures

Libraries often fail silently. Common patterns:
- **Canvas libraries**: Hit detection uses hidden canvas with specific requirements
- **React wrappers**: Props with new references trigger full re-renders
- **Physics simulations**: Timing/lifecycle issues have no error messages
- **Event handlers**: Must match exact shapes/sizes for detection

When something "just doesn't work" with no errors, suspect these patterns.
